<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Carte ‚Äì Ao√ªt 1944</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100%; }

    .legend {
      background: #fff;
      padding: 8px 10px;
      line-height: 1.4;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      border-radius: 6px;
      box-shadow: 0 0 12px rgba(0,0,0,.15);
    }

    /* Ic√¥nes Leaflet propres */
    .leaflet-div-icon { background: transparent; border: none; user-select: none; }
    .icon-swords svg, .icon-cross svg { display:block; }
    .icon-swords path,
    .icon-cross path, .icon-cross rect {
      vector-effect: non-scaling-stroke;
      shape-rendering: geometricPrecision;
    }

    /* ===== Contr√¥les (communes / dates) ===== */
    .ui-panel {
      background:#fff;
      padding:10px;
      border-radius:8px;
      box-shadow:0 0 12px rgba(0,0,0,.15);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 460px;
    }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row + .row { margin-top:8px; }

    .ui-panel select, .ui-panel input[type="date"] {
      padding:6px 8px; border:1px solid #ddd; border-radius:6px; background:#fff;
    }
    .ui-panel select { flex:1 1 auto; min-width:220px; }
    .pillbar {
      display:flex; gap:6px; overflow:auto; padding-bottom:2px; max-width:420px;
    }
    .pillbar::-webkit-scrollbar { height:6px; }
    .pill {
      flex:0 0 auto; padding:6px 10px; border:1px solid #d0d7de; border-radius:999px;
      background:#f6f8fa; cursor:pointer; white-space:nowrap; user-select:none;
      transition:background .15s, transform .05s;
    }
    .pill:hover { background:#eef2f6; }
    .pill:active { transform:translateY(1px); }
    .btn {
      padding:6px 10px; border:1px solid #d0d7de; border-radius:6px; background:#fff; cursor:pointer;
    }
    .btn:hover { background:#f3f4f6; }
    .muted { color:#555; font-size:12px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // --------- Carte ----------
    const map = L.map('map').setView([45.05, 5.83], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '¬© OpenStreetMap'
    }).addTo(map);

    // --------- Ic√¥nes SVG (on garde TES ic√¥nes) ----------
    const svgCross = `
      <svg width="26" height="26" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M10 2h4v6h6v4h-6v10h-4V12H4V8h6z" fill="#c1121f"/>
        <rect x="9.5" y="1.5" width="5" height="21" fill="none" stroke="#7a0a12" stroke-width="1"/>
        <rect x="1.5" y="7.5" width="21" height="5" fill="none" stroke="#7a0a12" stroke-width="1"/>
      </svg>`;
    const svgSwords = `
      <svg width="28" height="28" viewBox="0 0 24 24" aria-hidden="true">
        <g stroke="#0b2545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none">
          <path d="M4 5l7 7" />
          <path d="M20 5l-7 7" />
          <path d="M3 7l3-3" />
          <path d="M21 7l-3-3" />
          <path d="M7 9l-2 2" />
          <path d="M17 9l2 2" />
        </g>
      </svg>`;

    const iconCross  = L.divIcon({ className: 'icon-cross',  html: svgCross,  iconSize: [26,26], iconAnchor: [13,26], popupAnchor: [0,-22] });
    const iconSwords = L.divIcon({ className: 'icon-swords', html: svgSwords, iconSize: [28,28], iconAnchor: [14,28], popupAnchor: [0,-24] });
    const iconDot    = L.divIcon({ className: 'icon-dot',    html: '<svg width="20" height="20"><circle cx="10" cy="10" r="6" fill="#222"/></svg>', iconSize: [20,20], iconAnchor: [10,20], popupAnchor: [0,-18] });

    function getIcon(categorie = "") {
      const c = (categorie || "").toLowerCase();
      if (c.includes("ex√©cution") || c.includes("victime")) return iconCross;   // ‚úùÔ∏è
      if (c.includes("combat")) return iconSwords;                               // ‚öîÔ∏è
      return iconDot;                                                            // d√©faut
    }

    // --------- Index & donn√©es ---------
    const allMarkers = [];
    const communeIndex = new Map(); // "Commune" -> { markers:[], bounds:L.LatLngBounds }
    const points = [];              // {marker, latlng, date:Date|null, commune}

    function addToCommuneIndex(commune, marker) {
      const key = (commune || "").trim();
      if (!key) return;
      let entry = communeIndex.get(key);
      if (!entry) {
        entry = { markers: [], bounds: null };
        communeIndex.set(key, entry);
      }
      entry.markers.push(marker);
      const mlatlng = marker.getLatLng();
      entry.bounds = entry.bounds ? entry.bounds.extend(mlatlng) : L.latLngBounds(mlatlng, mlatlng);
    }

    function zoomToCommune(name) {
      const key = (name || "").trim();
      if (!communeIndex.has(key)) return;
      const entry = communeIndex.get(key);
      if (entry.bounds) {
        const b = entry.bounds;
        if (entry.markers.length === 1) {
          map.setView(b.getCenter(), 15, { animate: true });
        } else {
          map.fitBounds(b.pad(0.25), { animate: true });
        }
      }
      setHash({ commune: key });
    }

    function zoomAll() {
      if (allMarkers.length) {
        const allBounds = L.featureGroup(allMarkers).getBounds();
        map.fitBounds(allBounds.pad(0.2), { animate: true });
      }
      setHash({});
    }

    // --------- Chargement CSV ----------
    Papa.parse("data/victimes.csv?cb=" + Date.now(), {
      download: true,
      header: true,
      skipEmptyLines: true,
      complete: ({data}) => {
        console.log("Lignes lues :", data.length);

        data.forEach(row => {
          // En-t√™tes attendues :
          // Commune;Lieu;Date;Cat√©gorie;Victimes;Coordonn√©es;Source
          const coordsRaw = row["Coordonn√©es"];
          if (!coordsRaw) return;
          const parts = String(coordsRaw).replace(/"/g,"").split(",");
          if (parts.length !== 2) return;

          const lat = parseFloat(parts[0]);
          const lng = parseFloat(parts[1]);
          if (isNaN(lat) || isNaN(lng)) {
            console.warn("Coordonn√©es invalides:", coordsRaw, row);
            return;
          }

          const dateObj = parseEventDate(row["Date"]);

          const popup = `
            <b>${row["Commune"] || ""}</b><br/>
            <i>${row["Lieu"] || ""}</i><br/>
            üìÖ ${row["Date"] || ""}<br/>
            Cat√©gorie : ${row["Cat√©gorie"] || ""}<br/>
            Victimes : ${row["Victimes"] || ""}<br/>
            Source : ${row["Source"] || "‚Äî"}
          `;

          const marker = L.marker([lat, lng], { icon: getIcon(row["Cat√©gorie"]) })
            .addTo(map)
            .bindPopup(popup);

          allMarkers.push(marker);
          addToCommuneIndex(row["Commune"], marker);
          points.push({ marker, latlng: L.latLng(lat, lng), date: dateObj, commune: row["Commune"] || "" });
        });

        buildCommunesControl();
        buildDatesControl();   // ‚á¶ nouveau contr√¥le de dates

        // Hash URL (commune=..., date=YYYY-MM-DD_to_YYYY-MM-DD)
        const h = parseHash();
        if (h.dateFrom || h.dateTo) {
          zoomByDateRange(h.dateFrom, h.dateTo);
        } else if (h.commune) {
          zoomToCommune(h.commune);
        }
      },
      error: (err) => console.error("Erreur PapaParse:", err)
    });

    // --------- L√©gende ----------
    const legend = L.control({ position: "bottomright" });
    legend.onAdd = function () {
      const div = L.DomUtil.create("div", "legend");
      div.innerHTML = `
        <b>L√©gende</b><br/>
        <span style="display:inline-block;vertical-align:middle;margin-right:6px;">${svgCross}</span>
        Victimes / Ex√©cutions<br/>
        <span style="display:inline-block;vertical-align:middle;margin-right:6px;">${svgSwords}</span>
        Combats
      `;
      return div;
    };
    legend.addTo(map);

    // =========================
    //  Contr√¥le "Communes"
    // =========================
    function buildCommunesControl() {
      const communes = Array.from(communeIndex.keys()).sort((a,b) =>
        a.localeCompare(b, 'fr', { sensitivity:'base' })
      );

      const counts = communes.map(name => ({ name, n: communeIndex.get(name).markers.length }));
      counts.sort((a,b) => b.n - a.n);
      const top = counts.slice(0, 8).map(x => x.name);

      const Control = L.Control.extend({
        options: { position: 'topleft' },
        onAdd: function() {
          const container = L.DomUtil.create('div', 'ui-panel');
          container.innerHTML = `
            <div class="row">
              <strong>Communes</strong>
              <button class="btn" type="button" data-action="zoom-all" title="Revenir √† l‚Äôensemble">Tout voir</button>
            </div>
            <div class="row">
              <select id="communeSelect">
                <option value="">‚Äî Aller √† une commune ‚Äî</option>
                ${communes.map(n => `<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join('')}
              </select>
            </div>
            <div class="row">
              <div class="pillbar" id="pillbar">
                ${top.map(n => `<button class="pill" type="button" data-commune="${escapeHtml(n)}">${escapeHtml(n)}</button>`).join('')}
              </div>
            </div>
          `;

          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);

          container.querySelector('#communeSelect').addEventListener('change', e => {
            const name = e.target.value;
            if (name) zoomToCommune(name);
          });

          container.querySelector('#pillbar').addEventListener('click', e => {
            const btn = e.target.closest('button.pill');
            if (!btn) return;
            zoomToCommune(btn.dataset.commune);
          });

          container.querySelector('[data-action="zoom-all"]').addEventListener('click', zoomAll);

          return container;
        }
      });

      map.addControl(new Control());
    }

    // =========================
    //  Contr√¥le "Dates"
    // =========================
    function buildDatesControl() {
      // Collecte des dates valides
      const dated = points.filter(p => p.date instanceof Date && !isNaN(p.date));
      if (!dated.length) return;

      // min / max
      const minD = new Date(Math.min(...dated.map(p => p.date.getTime())));
      const maxD = new Date(Math.max(...dated.map(p => p.date.getTime())));

      const Control = L.Control.extend({
        options: { position: 'topleft' },
        onAdd: function() {
          const container = L.DomUtil.create('div', 'ui-panel');
          container.innerHTML = `
            <div class="row">
              <strong>Dates</strong>
              <span class="muted">(zoom par p√©riode)</span>
              <button class="btn" type="button" data-action="zoom-all" title="Revenir √† l‚Äôensemble">Tout voir</button>
            </div>
            <div class="row">
              <input type="date" id="dateFrom" value="${toISODate(minD)}" min="${toISODate(minD)}" max="${toISODate(maxD)}">
              <span>‚Äî</span>
              <input type="date" id="dateTo"   value="${toISODate(maxD)}" min="${toISODate(minD)}" max="${toISODate(maxD)}">
              <button class="btn" type="button" data-action="zoom-date">Zoom</button>
            </div>
            <div class="row">
              <div class="pillbar" id="datesPills"></div>
            </div>
          `;

          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);

          // Boutons rapides = jours distincts (max 8)
          const dayMap = new Map(); // 'YYYY-MM-DD' -> count
          dated.forEach(p => {
            const key = toISODate(p.date);
            dayMap.set(key, (dayMap.get(key) || 0) + 1);
          });
          const topDays = Array.from(dayMap.entries())
            .sort((a,b) => b[1] - a[1])
            .slice(0, 8)
            .map(([iso]) => iso);

          const pills = container.querySelector('#datesPills');
          pills.innerHTML = topDays.map(iso => {
            const label = formatFR(iso);
            return `<button class="pill" type="button" data-day="${iso}">${escapeHtml(label)}</button>`;
          }).join('');

          // Events
          container.querySelector('[data-action="zoom-all"]').addEventListener('click', zoomAll);

          container.querySelector('[data-action="zoom-date"]').addEventListener('click', () => {
            const from = container.querySelector('#dateFrom').value || toISODate(minD);
            const to   = container.querySelector('#dateTo').value   || toISODate(maxD);
            zoomByDateRange(from, to);
          });

          pills.addEventListener('click', e => {
            const btn = e.target.closest('button.pill');
            if (!btn) return;
            const iso = btn.dataset.day;
            // Zoom sur la journ√©e (from = to = iso)
            container.querySelector('#dateFrom').value = iso;
            container.querySelector('#dateTo').value   = iso;
            zoomByDateRange(iso, iso);
          });

          // S'il y a une p√©riode dans le hash, la refl√©ter dans les inputs
          const h = parseHash();
          if (h.dateFrom) container.querySelector('#dateFrom').value = h.dateFrom;
          if (h.dateTo)   container.querySelector('#dateTo').value   = h.dateTo;

          return container;
        }
      });

      map.addControl(new Control());
    }

    // --------- Zoom par p√©riode (sans filtrer l‚Äôaffichage) ----------
    function zoomByDateRange(fromISO, toISO) {
      const from = parseISODate(fromISO) || null;
      const to   = parseISODate(toISO)   || null;
      if (!from && !to) return;

      // Bornes inclusives (00:00 ‚Üí 23:59:59)
      const start = from ? new Date(from.getFullYear(), from.getMonth(), from.getDate(), 0,0,0) : null;
      const end   = to   ? new Date(to.getFullYear(),   to.getMonth(),   to.getDate(),   23,59,59) : null;

      const inRange = points.filter(p => {
        if (!(p.date instanceof Date) || isNaN(p.date)) return false;
        const t = p.date.getTime();
        if (start && t < start.getTime()) return false;
        if (end   && t > end.getTime())   return false;
        return true;
      });

      if (!inRange.length) {
        console.warn("Aucun point dans cette p√©riode.");
        return;
      }

      const bounds = L.featureGroup(inRange.map(p => p.marker)).getBounds();
      map.fitBounds(bounds.pad(0.25), { animate: true });

      setHash({ dateFrom: toISODate(start || inRange[0].date), dateTo: toISODate(end || inRange[inRange.length-1].date) });
    }

    // =========================
    //  Utilitaires dates / hash
    // =========================
    function toISODate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const da = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }
    function parseISODate(iso) {
      const m = String(iso||'').match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!m) return null;
      return new Date(+m[1], +m[2]-1, +m[3]);
    }
    function formatFR(iso) {
      const d = parseISODate(iso);
      return d ? d.toLocaleDateString('fr-FR', { day:'2-digit', month:'long', year:'numeric' }) : iso;
    }

    // Parse robuste de dates FR vari√©es (ISO, JJ/MM/AAAA, AAAAMMJJ, "22 ao√ªt 1944", etc.)
    function parseEventDate(raw) {
      if (!raw) return null;
      let s = String(raw).trim();

      // ISO YYYY-MM-DD / YYYY/MM/DD
      let m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
      if (m) return new Date(+m[1], +m[2]-1, +m[3]);

      // YYYYMMDD
      m = s.match(/^(\d{4})(\d{2})(\d{2})$/);
      if (m) return new Date(+m[1], +m[2]-1, +m[3]);

      // JJ/MM/AAAA ou JJ-MM-AAAA
      m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
      if (m) return new Date(+m[3], +m[2]-1, +m[1]);

      // "22 ao√ªt 1944" / "22 aout 1944"
      const months = {
        janvier:1, fevrier:2, f√©vrier:2, mars:3, avril:4, mai:5, juin:6, juillet:7,
        aout:8, ao√ªt:8, septembre:9, octobre:10, novembre:11, decembre:12, d√©cembre:12
      };
      const sNorm = s.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      m = sNorm.match(/^(\d{1,2})\s+([a-z]+)\s+(\d{4})$/);
      if (m && months[m[2]] != null) return new Date(+m[3], months[m[2]]-1, +m[1]);

      // Si rien ne marche : null
      return null;
    }

    function parseHash() {
      const out = {};
      const h = location.hash.replace(/^#/, '');
      if (!h) return out;
      const params = new URLSearchParams(h);
      if (params.has('commune')) out.commune = decodeURIComponent(params.get('commune'));
      if (params.has('date')) {
        const v = params.get('date');
        const m = v.match(/^(\d{4}-\d{2}-\d{2})_to_(\d{4}-\d{2}-\d{2})$/);
        if (m) { out.dateFrom = m[1]; out.dateTo = m[2]; }
      }
      if (params.has('dateFrom')) out.dateFrom = params.get('dateFrom');
      if (params.has('dateTo'))   out.dateTo   = params.get('dateTo');
      return out;
    }
    function setHash({ commune, dateFrom, dateTo }) {
      const p = new URLSearchParams();
      if (commune) p.set('commune', encodeURIComponent(commune));
      if (dateFrom && dateTo) {
        p.set('dateFrom', dateFrom);
        p.set('dateTo',   dateTo);
      }
      const hash = p.toString();
      location.hash = hash ? '#' + hash : '';
    }

    // ==============
    // Fin du script
    // ==============
  </script>
</body>
</html>
