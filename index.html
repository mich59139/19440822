<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Carte ‚Äì Ao√ªt 1944</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    /* Prend en compte les "safe areas" iOS (encoches) */
    body { padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
    #map { height: 100vh; width: 100%; }

    .legend {
      background: #fff;
      padding: 8px 10px;
      line-height: 1.4;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      border-radius: 6px;
      box-shadow: 0 0 12px rgba(0,0,0,.15);
    }

    /* Ic√¥nes Leaflet propres */
    .leaflet-div-icon { background: transparent; border: none; user-select: none; }
    .icon-swords svg, .icon-cross svg { display:block; }
    .icon-swords path,
    .icon-cross path, .icon-cross rect {
      vector-effect: non-scaling-stroke;
      shape-rendering: geometricPrecision;
    }

    /* ========= Mobile friendly : place le select √† c√¥t√© du zoom ========= */
    .leaflet-top.leaflet-left {
      display: flex;
      gap: 8px;
      align-items: flex-start;
      flex-wrap: wrap; /* si l'espace manque, passe √† la ligne */
      padding-top: env(safe-area-inset-top);
      padding-left: env(safe-area-inset-left);
    }

    /* Grossit un peu les boutons + / ‚Äì pour le doigt */
    .leaflet-bar a {
      width: 40px; height: 40px; line-height: 40px;
      font-size: 22px;
    }

    /* Bloc compact pour la liste "Communes" */
    .communes-inline {
      background: #fff;
      padding: 4px 6px;
      border-radius: 8px;
      box-shadow: 0 1px 5px rgba(0,0,0,.3);
      font: 16px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; /* 16px √©vite le zoom iOS */
      max-width: min(60vw, 320px);
    }
    .communes-inline select {
      border: 1px solid #d0d7de;
      border-radius: 6px;
      padding: 8px 10px; /* touch target g√©n√©reuse */
      background: #fff;
      max-width: 100%;
      font-size: 16px; /* anti-zoom iOS */
    }

    /* Sur tr√®s petits √©crans, on empile sous le zoom, et on √©largit le select */
    @media (max-width: 480px) {
      .leaflet-top.leaflet-left { flex-direction: column; align-items: stretch; gap: 6px; }
      .communes-inline { max-width: 85vw; }
      .legend { font-size: 13px; }
    }
  </style>
  <!-- √©vite le 404 favicon en local -->
  <link rel="icon" href="data:," />
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // ============ Carte ============
    const map = L.map('map', { zoomControl: true }).setView([45.05, 5.83], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '¬© OpenStreetMap'
    }).addTo(map);

    // ============ Ic√¥nes (on garde TES ic√¥nes) ============
    const svgCross = `
      <svg width="26" height="26" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M10 2h4v6h6v4h-6v10h-4V12H4V8h6z" fill="#c1121f"/>
        <rect x="9.5" y="1.5" width="5" height="21" fill="none" stroke="#7a0a12" stroke-width="1"/>
        <rect x="1.5" y="7.5" width="21" height="5" fill="none" stroke="#7a0a12" stroke-width="1"/>
      </svg>`;
    const svgSwords = `
      <svg width="28" height="28" viewBox="0 0 24 24" aria-hidden="true">
        <g stroke="#0b2545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none">
          <path d="M4 5l7 7" />
          <path d="M20 5l-7 7" />
          <path d="M3 7l3-3" />
          <path d="M21 7l-3-3" />
          <path d="M7 9l-2 2" />
          <path d="M17 9l2 2" />
        </g>
      </svg>`;

    const iconCross  = L.divIcon({ className: 'icon-cross',  html: svgCross,  iconSize: [26,26], iconAnchor: [13,26], popupAnchor: [0,-22] });
    const iconSwords = L.divIcon({ className: 'icon-swords', html: svgSwords, iconSize: [28,28], iconAnchor: [14,28], popupAnchor: [0,-24] });
    const iconDot    = L.divIcon({ className: 'icon-dot',    html: '<svg width="20" height="20"><circle cx="10" cy="10" r="6" fill="#222"/></svg>', iconSize: [20,20], iconAnchor: [10,20], popupAnchor: [0,-18] });

    function getIcon(categorie = "") {
      const c = (categorie || "").toLowerCase();
      if (c.includes("ex√©cution") || c.includes("victime")) return iconCross;   // ‚úùÔ∏è
      if (c.includes("combat")) return iconSwords;                               // ‚öîÔ∏è
      return iconDot;                                                            // d√©faut
    }

    // ============ Donn√©es & index ============
    const allMarkers = [];
    const communeIndex = new Map(); // "Commune" -> { markers:[], bounds:L.LatLngBounds }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;').replace(/</g, '&lt;')
        .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function addToCommuneIndex(commune, marker) {
      const key = (commune || "").trim();
      if (!key) return;
      let entry = communeIndex.get(key);
      if (!entry) {
        entry = { markers: [], bounds: null };
        communeIndex.set(key, entry);
      }
      entry.markers.push(marker);
      const ll = marker.getLatLng();
      entry.bounds = entry.bounds ? entry.bounds.extend(ll) : L.latLngBounds(ll, ll);
    }

    function zoomToCommune(name) {
      if (!name) return zoomAll();
      const entry = communeIndex.get(name);
      if (!entry || !entry.bounds) return;
      const b = entry.bounds;
      if (entry.markers.length === 1) map.setView(b.getCenter(), 15, { animate: true });
      else map.fitBounds(b.pad(0.25), { animate: true });
      setHash({ commune: name });
    }

    function zoomAll() {
      if (allMarkers.length) {
        const allBounds = L.featureGroup(allMarkers).getBounds();
        map.fitBounds(allBounds.pad(0.2), { animate: true });
      }
      setHash({});
    }

    // ============ Chargement CSV ============
    Papa.parse("data/victimes.csv?cb=" + Date.now(), {
      download: true,
      header: true,
      skipEmptyLines: true,
      complete: ({data}) => {
        console.log("Lignes lues :", data.length);

        data.forEach(row => {
          // En-t√™tes attendues :
          // Commune;Lieu;Date;Cat√©gorie;Victimes;Coordonn√©es;Source
          const coordsRaw = row["Coordonn√©es"];
          if (!coordsRaw) return;
          const parts = String(coordsRaw).replace(/"/g,"").split(",");
          if (parts.length !== 2) return;

          const lat = parseFloat(parts[0]);
          const lng = parseFloat(parts[1]);
          if (isNaN(lat) || isNaN(lng)) {
            console.warn("Coordonn√©es invalides:", coordsRaw, row);
            return;
          }

          const popup = `
            <b>${row["Commune"] || ""}</b><br/>
            <i>${row["Lieu"] || ""}</i><br/>
            üìÖ ${row["Date"] || ""}<br/>
            Cat√©gorie : ${row["Cat√©gorie"] || ""}<br/>
            Victimes : ${row["Victimes"] || ""}<br/>
            Source : ${row["Source"] || "‚Äî"}
          `;

          const marker = L.marker([lat, lng], { icon: getIcon(row["Cat√©gorie"]) })
            .addTo(map)
            .bindPopup(popup);

          allMarkers.push(marker);
          addToCommuneIndex(row["Commune"], marker);
        });

        buildCommunesControl();   // liste d√©roulante coll√©e au zoom

        // Hash URL
        const h = parseHash();
        if (h.commune) zoomToCommune(h.commune);
      },
      error: (err) => console.error("Erreur PapaParse:", err)
    });

    // ============ L√©gende ============
    const legend = L.control({ position: "bottomright" });
    legend.onAdd = function () {
      const div = L.DomUtil.create("div", "legend");
      div.innerHTML = `
        <b>L√©gende</b><br/>
        <span style="display:inline-block;vertical-align:middle;margin-right:6px;">${svgCross}</span>
        Victimes / Ex√©cutions<br/>
        <span style="display:inline-block;vertical-align:middle;margin-right:6px;">${svgSwords}</span>
        Combats
      `;
      return div;
    };
    legend.addTo(map);

    // ============ Contr√¥le "Communes" (inline, √† c√¥t√© du zoom) ============
    function buildCommunesControl() {
      const communes = Array.from(communeIndex.keys())
        .sort((a,b) => a.localeCompare(b, 'fr', { sensitivity:'base' }));

      const CommunesControl = L.Control.extend({
        options: { position: 'topleft' },
        onAdd: function() {
          const c = L.DomUtil.create('div', 'communes-inline');
          c.innerHTML = `
            <label for="communeSelect" class="sr-only" style="position:absolute;left:-9999px;">Communes</label>
            <select id="communeSelect" aria-label="Communes">
              <option value="">‚Äî Tout voir ‚Äî</option>
              ${communes.map(n => `<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join('')}
            </select>
          `;
          L.DomEvent.disableClickPropagation(c);
          L.DomEvent.disableScrollPropagation(c);

          const sel = c.querySelector('#communeSelect');
          sel.addEventListener('change', e => {
            const name = e.target.value;
            if (name) zoomToCommune(name); else zoomAll();
          });

          // refl√©ter le hash (si partage d‚ÄôURL)
          const h = parseHash();
          if (h.commune && communes.includes(h.commune)) sel.value = h.commune;

          return c;
        }
      });
      map.addControl(new CommunesControl());
    }

    // ============ Hash URL ============
    function parseHash() {
      const out = {};
      const h = location.hash.replace(/^#/, '');
      if (!h) return out;
      const params = new URLSearchParams(h);
      if (params.has('commune')) out.commune = decodeURIComponent(params.get('commune'));
      return out;
    }
    function setHash({ commune }) {
      const p = new URLSearchParams();
      if (commune) p.set('commune', encodeURIComponent(commune));
      const hash = p.toString();
      location.hash = hash ? '#' + hash : '';
    }
  </script>
</body>
</html>
