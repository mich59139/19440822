<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Carte ‚Äì Ao√ªt 1944</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100%; }

    .legend {
      background: #fff;
      padding: 8px 10px;
      line-height: 1.4;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      border-radius: 6px;
      box-shadow: 0 0 12px rgba(0,0,0,.15);
    }

    /* Ic√¥nes Leaflet propres */
    .leaflet-div-icon { background: transparent; border: none; user-select: none; }
    .icon-swords svg, .icon-cross svg { display:block; }
    .icon-swords path,
    .icon-cross path, .icon-cross rect {
      vector-effect: non-scaling-stroke;
      shape-rendering: geometricPrecision;
    }

    /* ===== Panneaux UI (seulement des listes d√©roulantes) ===== */
    .ui-panel {
      background:#fff;
      padding:10px;
      border-radius:8px;
      box-shadow:0 0 12px rgba(0,0,0,.15);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 460px;
    }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row + .row { margin-top:8px; }
    .ui-panel select {
      padding:6px 8px; border:1px solid #ddd; border-radius:6px; background:#fff;
    }
    .grow { flex:1 1 auto; min-width:220px; }
  </style>
  <!-- (facultatif) √©vite le 404 favicon en local -->
  <link rel="icon" href="data:," />
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // --------- Carte ----------
    const map = L.map('map').setView([45.05, 5.83], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '¬© OpenStreetMap'
    }).addTo(map);

    // --------- Ic√¥nes SVG (on garde TES ic√¥nes) ----------
    const svgCross = `
      <svg width="26" height="26" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M10 2h4v6h6v4h-6v10h-4V12H4V8h6z" fill="#c1121f"/>
        <rect x="9.5" y="1.5" width="5" height="21" fill="none" stroke="#7a0a12" stroke-width="1"/>
        <rect x="1.5" y="7.5" width="21" height="5" fill="none" stroke="#7a0a12" stroke-width="1"/>
      </svg>`;
    const svgSwords = `
      <svg width="28" height="28" viewBox="0 0 24 24" aria-hidden="true">
        <g stroke="#0b2545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none">
          <path d="M4 5l7 7" />
          <path d="M20 5l-7 7" />
          <path d="M3 7l3-3" />
          <path d="M21 7l-3-3" />
          <path d="M7 9l-2 2" />
          <path d="M17 9l2 2" />
        </g>
      </svg>`;

    const iconCross  = L.divIcon({ className: 'icon-cross',  html: svgCross,  iconSize: [26,26], iconAnchor: [13,26], popupAnchor: [0,-22] });
    const iconSwords = L.divIcon({ className: 'icon-swords', html: svgSwords, iconSize: [28,28], iconAnchor: [14,28], popupAnchor: [0,-24] });
    const iconDot    = L.divIcon({ className: 'icon-dot',    html: '<svg width="20" height="20"><circle cx="10" cy="10" r="6" fill="#222"/></svg>', iconSize: [20,20], iconAnchor: [10,20], popupAnchor: [0,-18] });

    function getIcon(categorie = "") {
      const c = (categorie || "").toLowerCase();
      if (c.includes("ex√©cution") || c.includes("victime")) return iconCross;   // ‚úùÔ∏è
      if (c.includes("combat")) return iconSwords;                               // ‚öîÔ∏è
      return iconDot;                                                            // d√©faut
    }

    // --------- Index & donn√©es ---------
    const allMarkers = [];
    const communeIndex = new Map(); // "Commune" -> { markers:[], bounds:L.LatLngBounds }
    const points = [];              // {marker, latlng, date:Date|null, commune}

    // Utils (d√©clar√©s t√¥t)
    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
    function toISODate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const da = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }
    function parseISODate(iso) {
      const m = String(iso||'').match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!m) return null;
      return new Date(+m[1], +m[2]-1, +m[3]);
    }
    function formatFR(iso) {
      const d = parseISODate(iso);
      return d ? d.toLocaleDateString('fr-FR', { day:'2-digit', month:'long', year:'numeric' }) : iso;
    }
    // Parse dates FR vari√©es
    function parseEventDate(raw) {
      if (!raw) return null;
      let s = String(raw).trim();

      let m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); // ISO YYYY-MM-DD
      if (m) return new Date(+m[1], +m[2]-1, +m[3]);

      m = s.match(/^(\d{4})(\d{2})(\d{2})$/); // YYYYMMDD
      if (m) return new Date(+m[1], +m[2]-1, +m[3]);

      m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/); // JJ/MM/AAAA
      if (m) return new Date(+m[3], +m[2]-1, +m[1]);

      const months = { janvier:1, fevrier:2, f√©vrier:2, mars:3, avril:4, mai:5, juin:6, juillet:7,
        aout:8, ao√ªt:8, septembre:9, octobre:10, novembre:11, decembre:12, d√©cembre:12 };
      const sNorm = s.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      m = sNorm.match(/^(\d{1,2})\s+([a-z]+)\s+(\d{4})$/); // "22 ao√ªt 1944"
      if (m && months[m[2]] != null) return new Date(+m[3], months[m[2]]-1, +m[1]);

      return null;
    }

    function addToCommuneIndex(commune, marker) {
      const key = (commune || "").trim();
      if (!key) return;
      let entry = communeIndex.get(key);
      if (!entry) {
        entry = { markers: [], bounds: null };
        communeIndex.set(key, entry);
      }
      entry.markers.push(marker);
      const mlatlng = marker.getLatLng();
      entry.bounds = entry.bounds ? entry.bounds.extend(mlatlng) : L.latLngBounds(mlatlng, mlatlng);
    }

    function zoomToCommune(name) {
      if (!name) return zoomAll();
      const entry = communeIndex.get(name);
      if (!entry || !entry.bounds) return;
      const b = entry.bounds;
      if (entry.markers.length === 1) map.setView(b.getCenter(), 15, { animate: true });
      else map.fitBounds(b.pad(0.25), { animate: true });
      setHash({ commune: name });
    }

    function zoomAll() {
      if (allMarkers.length) {
        const allBounds = L.featureGroup(allMarkers).getBounds();
        map.fitBounds(allBounds.pad(0.2), { animate: true });
      }
      setHash({});
    }

    // --------- Chargement CSV ----------
    Papa.parse("data/victimes.csv?cb=" + Date.now(), {
      download: true,
      header: true,
      skipEmptyLines: true,
      complete: ({data}) => {
        console.log("Lignes lues :", data.length);

        data.forEach(row => {
          // En-t√™tes attendues :
          // Commune;Lieu;Date;Cat√©gorie;Victimes;Coordonn√©es;Source
          const coordsRaw = row["Coordonn√©es"];
          if (!coordsRaw) return;
          const parts = String(coordsRaw).replace(/"/g,"").split(",");
          if (parts.length !== 2) return;

          const lat = parseFloat(parts[0]);
          const lng = parseFloat(parts[1]);
          if (isNaN(lat) || isNaN(lng)) {
            console.warn("Coordonn√©es invalides:", coordsRaw, row);
            return;
          }

          const dateObj = parseEventDate(row["Date"]);
          const popup = `
            <b>${row["Commune"] || ""}</b><br/>
            <i>${row["Lieu"] || ""}</i><br/>
            üìÖ ${row["Date"] || ""}<br/>
            Cat√©gorie : ${row["Cat√©gorie"] || ""}<br/>
            Victimes : ${row["Victimes"] || ""}<br/>
            Source : ${row["Source"] || "‚Äî"}
          `;

          const marker = L.marker([lat, lng], { icon: getIcon(row["Cat√©gorie"]) })
            .addTo(map)
            .bindPopup(popup);

          allMarkers.push(marker);
          addToCommuneIndex(row["Commune"], marker);
          points.push({ marker, latlng: L.latLng(lat, lng), date: dateObj, commune: row["Commune"] || "" });
        });

        buildCommunesControl();   // liste d√©roulante
        buildDatesControl();      // 2 listes d√©roulantes (Du/Au)

        // Hash URL
        const h = parseHash();
        if (h.dateFrom || h.dateTo) zoomByDateRange(h.dateFrom, h.dateTo, {updateInputs:true});
        else if (h.commune) zoomToCommune(h.commune);
      },
      error: (err) => console.error("Erreur PapaParse:", err)
    });

    // --------- L√©gende ----------
    const legend = L.control({ position: "bottomright" });
    legend.onAdd = function () {
      const div = L.DomUtil.create("div", "legend");
      div.innerHTML = `
        <b>L√©gende</b><br/>
        <span style="display:inline-block;vertical-align:middle;margin-right:6px;">${svgCross}</span>
        Victimes / Ex√©cutions<br/>
        <span style="display:inline-block;vertical-align:middle;margin-right:6px;">${svgSwords}</span>
        Combats
      `;
      return div;
    };
    legend.addTo(map);

    // =========================
    //  Contr√¥le "Communes" (liste)
    // =========================
    function buildCommunesControl() {
      const communes = Array.from(communeIndex.keys())
        .sort((a,b) => a.localeCompare(b, 'fr', { sensitivity:'base' }));

      const CommunesControl = L.Control.extend({
        options: { position: 'topleft' },
        onAdd: function() {
          const c = L.DomUtil.create('div', 'ui-panel');
          c.innerHTML = `
            <div class="row">
              <label for="communeSelect"><strong>Communes</strong></label>
              <select id="communeSelect" class="grow">
                <option value="">‚Äî Tout voir ‚Äî</option>
                ${communes.map(n => `<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join('')}
              </select>
            </div>
          `;
          L.DomEvent.disableClickPropagation(c);
          L.DomEvent.disableScrollPropagation(c);

          const sel = c.querySelector('#communeSelect');
          sel.addEventListener('change', e => {
            const name = e.target.value;
            if (name) zoomToCommune(name); else zoomAll();
          });

          // refl√©ter le hash
          const h = parseHash();
          if (h.commune && communes.includes(h.commune)) sel.value = h.commune;

          return c;
        }
      });
      map.addControl(new CommunesControl());
    }

    // =========================
    //  Contr√¥le "Dates" (listes Du/Au)
    // =========================
    function buildDatesControl() {
      // Dates valides
      const dated = points.filter(p => p.date instanceof Date && !isNaN(p.date));
      if (!dated.length) return;

      // Jours uniques
      const days = Array.from(new Set(dated.map(p => toISODate(p.date)))).sort();

      const minISO = days[0];
      const maxISO = days[days.length - 1];

      const DatesControl = L.Control.extend({
        options: { position: 'topright' },
        onAdd: function() {
          const c = L.DomUtil.create('div', 'ui-panel');
          c.innerHTML = `
            <div class="row">
              <label for="dateFromSelect"><strong>Du</strong></label>
              <select id="dateFromSelect">
                <option value="">Toutes dates</option>
                ${days.map(d => `<option value="${d}">${escapeHtml(formatFR(d))}</option>`).join('')}
              </select>
              <label for="dateToSelect"><strong>Au</strong></label>
              <select id="dateToSelect">
                <option value="">Toutes dates</option>
                ${days.map(d => `<option value="${d}">${escapeHtml(formatFR(d))}</option>`).join('')}
              </select>
            </div>
          `;
          L.DomEvent.disableClickPropagation(c);
          L.DomEvent.disableScrollPropagation(c);

          const fromSel = c.querySelector('#dateFromSelect');
          const toSel   = c.querySelector('#dateToSelect');

          // Valeurs par d√©faut : min ‚Üí max
          fromSel.value = minISO;
          toSel.value   = maxISO;

          const onChange = () => {
            let f = fromSel.value || '';
            let t = toSel.value   || '';
            if (!f && !t) { zoomAll(); return; }

            // Normaliser : si une borne manque, utiliser min/max
            if (!f) f = minISO;
            if (!t) t = maxISO;

            // Corriger l'ordre si besoin
            if (f > t) { const tmp = f; f = t; t = tmp; fromSel.value = f; toSel.value = t; }

            zoomByDateRange(f, t, {updateInputs:false});
          };

          fromSel.addEventListener('change', onChange);
          toSel  .addEventListener('change', onChange);

          // refl√©ter hash (si pr√©sent)
          const h = parseHash();
          if (h.dateFrom && days.includes(h.dateFrom)) fromSel.value = h.dateFrom;
          if (h.dateTo   && days.includes(h.dateTo))   toSel.value   = h.dateTo;

          // Premier zoom par d√©faut (si hash pr√©sent)
          onChange();

          return c;
        }
      });
      map.addControl(new DatesControl());
    }

    // --------- Zoom par p√©riode ----------
    function zoomByDateRange(fromISO, toISO, {updateInputs=true}={}) {
      const from = parseISODate(fromISO) || null;
      const to   = parseISODate(toISO)   || null;
      if (!from && !to) return;

      const start = from ? new Date(from.getFullYear(), from.getMonth(), from.getDate(), 0,0,0) : null;
      const end   = to   ? new Date(to.getFullYear(),   to.getMonth(),   to.getDate(),   23,59,59) : null;

      const inRange = points.filter(p => {
        if (!(p.date instanceof Date) || isNaN(p.date)) return false;
        const t = p.date.getTime();
        if (start && t < start.getTime()) return false;
        if (end   && t > end.getTime())   return false;
        return true;
      });

      if (!inRange.length) {
        console.warn("Aucun point dans cette p√©riode.");
        return;
      }

      const bounds = L.featureGroup(inRange.map(p => p.marker)).getBounds();
      map.fitBounds(bounds.pad(0.25), { animate: true });

      setHash({ dateFrom: toISODate(start || inRange[0].date), dateTo: toISODate(end || inRange[inRange.length-1].date) });
    }

    // --------- Hash URL ---------
    function parseHash() {
      const out = {};
      const h = location.hash.replace(/^#/, '');
      if (!h) return out;
      const params = new URLSearchParams(h);
      if (params.has('commune')) out.commune = decodeURIComponent(params.get('commune'));
      if (params.has('dateFrom')) out.dateFrom = params.get('dateFrom');
      if (params.has('dateTo'))   out.dateTo   = params.get('dateTo');
      return out;
    }
    function setHash({ commune, dateFrom, dateTo }) {
      const p = new URLSearchParams();
      if (commune) p.set('commune', encodeURIComponent(commune));
      if (dateFrom && dateTo) {
        p.set('dateFrom', dateFrom);
        p.set('dateTo',   dateTo);
      }
      const hash = p.toString();
      location.hash = hash ? '#' + hash : '';
    }
  </script>
</body>
</html>
